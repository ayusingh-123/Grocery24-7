
 "hist": {
 "prefix": "ooo****",
 "body": [
 "#include <iostream>",
 "#include <opencv2/opencv.hpp>",
 "",
 "//HISTOGRAM OF A GRAYSCALE IMAGE : ",
 "int main1()",
 "{",
 " cv::Mat img = cv::imread(\"./Girl.jpg\" ,cv::IMREAD_GRAYSCALE); ",
 " ",
 " // define histogram parameters ",
 " int histSize = 256 ;",
 " float range[] = {0,256}; ",
 " const float *histRange[] = {range} ; ",
 "",
 " // calculate histogram for the image ",
 " cv::Mat hist ; ",
 " cv::calcHist(&img,1,0,cv::Mat(),hist,1, &histSize,histRange); ",
 "",
 " // define the width and height for the historgam image ",
 " int hist_w = 256 ;",
 " int hist_h = 200 ; ",
 " //draw the histimage ",
 " cv::Mat histImg(hist_h,hist_w,CV_8UC3,cv::Scalar(0,0,0));",
 " //normalize the histogram image ",
 " cv::normalize(hist , hist , 0 , histImg.rows ,cv::NORM_MINMAX); ",
 "",
 " // connects the line ",
 " for(int i = 1 ; i < histSize ; i++)",
 " {",
 " cv::line(histImg,",
 " cv::Point(i-1, hist_h -(hist.at<float>(i-1))),",
 " cv::Point(i, hist_h-(hist.at<float>(i))), ",
 " cv::Scalar(255,0,0),2,8,0); ",
 " }",
 " cv::imshow(\"original\", img); ",
 " cv::waitKey(0) ;",
 " cv::imshow(\"histogram\", histImg); ",
 " cv::waitKey(0) ;",
 "",
 " return 0 ; ",
 "}",
 "",
 "//HISTOGRAM OF A COLOR IMAGE INTO 3 CHANNELS ",
 "int main2()",
 "{",
 " cv::Mat img = cv::imread(\"/home/kpit/opencv/samples/data/messi5.jpg\"); ",
 "",
 " cv::Mat channels[3] ;",
 " cv::split(img,channels); ",
 "",
 " cv::Mat Blue = channels[0] ;",
 " cv::Mat Green = channels[1] ;",
 " cv::Mat Red = channels[2] ;",
 "",
 " int histSize = 256 ; ",
 " float range[] = {0,256} ;",
 " const float* histRange[] = {range} ; ",
 "",
 " cv::Mat hist_blue ; ",
 " cv::Mat hist_green ; ",
 " cv::Mat hist_red ;",
 "",
 " cv::calcHist(&Blue,1,0,cv::Mat(),hist_blue,1,&histSize,histRange);",
 "",
 " cv::calcHist(&Green,1,0,cv::Mat(),hist_green,1,&histSize,histRange); ",
 "",
 " cv::calcHist(&Red,1,0,cv::Mat(),hist_red,1,&histSize,histRange); ",
 "",
 " int hist_H = 500; ",
 " int hist_W = 500; ",
 "",
 " cv::Mat histBlue(hist_H,hist_W,CV_8UC3, cv::Scalar(0,0,0)) ;",
 "",
 " cv::Mat histGreen(hist_H,hist_W,CV_8UC3, cv::Scalar(0,0,0)) ;",
 "",
 " cv::Mat histRed(hist_H,hist_W,CV_8UC3, cv::Scalar(0,0,0)) ;",
 "",
 " cv::normalize(hist_blue,hist_blue,0,histBlue.rows, cv::NORM_MINMAX); ",
 "",
 " cv::normalize(hist_green,hist_green,0,histGreen.rows, cv::NORM_MINMAX); ",
 "",
 " cv::normalize(hist_red,hist_red,0,histRed.rows, cv::NORM_MINMAX); ",
 "",
 " for(int i = 1 ; i < histSize;i++)",
 " {",
 " cv::line(histBlue,",
 " cv::Point(i-1,hist_H-(hist_blue.at<float>(i-1))),",
 " cv::Point(i,hist_H-(hist_blue.at<float>(i))),",
 " cv::Scalar(255,0,0),3,8,0); ",
 "",
 " cv::line(histGreen,",
 " cv::Point(i-1,hist_H-(hist_green.at<float>(i-1))),",
 " cv::Point(i,hist_H-(hist_green.at<float>(i))),",
 " cv::Scalar(0,255,0),3,8,0);",
 "",
 " cv::line(histRed,",
 " cv::Point(i-1,hist_H-(hist_red.at<float>(i-1))),",
 " cv::Point(i,hist_H-(hist_red.at<float>(i))),",
 " cv::Scalar(0,0,255),3,8,0); ",
 " }",
 "",
 " cv::imshow(\"original\" , img); ",
 " cv::waitKey(0) ;",
 " cv::imshow(\"Blue\" , histBlue); ",
 " cv::waitKey(0) ;",
 " cv::imshow(\"Green\" , histGreen); ",
 " cv::waitKey(0) ;",
 " cv::imshow(\"Red\" , histRed); ",
 " cv::waitKey(0) ;",
 "",
 " return 0; ",
 "}",
 "",
 "////HISTOGRAM OF A COLOR IMAGE INTO 1 image ",
 "int main3()",
 "{",
 " cv::Mat img = cv::imread(\"/home/kpit/opencv/samples/data/messi5.jpg\"); ",
 "",
 " cv::Mat channels[3] ;",
 " cv::split(img,channels); ",
 "",
 " cv::Mat Blue = channels[0] ;",
 " cv::Mat Green = channels[1] ;",
 " cv::Mat Red = channels[2] ;",
 "",
 " int histSize = 256 ; ",
 " float range[] = {0,256} ;",
 " const float* histRange[] = {range} ; ",
 "",
 " cv::Mat hist_blue ; ",
 " cv::Mat hist_green ; ",
 " cv::Mat hist_red ;",
 "",
 " cv::calcHist(&Blue,1,0,cv::Mat(),hist_blue,1,&histSize,histRange);",
 "",
 " cv::calcHist(&Green,1,0,cv::Mat(),hist_green,1,&histSize,histRange); ",
 "",
 " cv::calcHist(&Red,1,0,cv::Mat(),hist_red,1,&histSize,histRange); ",
 "",
 " int hist_H = 500; ",
 " int hist_W = 500; ",
 "",
 " cv::Mat histUni(hist_H,hist_W,CV_8UC3, cv::Scalar(0,0,0)) ;",
 " // cv::Mat histGreen(hist_H,hist_W,CV_8UC3, cv::Scalar(0,0,0)) ;",
 " // cv::Mat histRed(hist_H,hist_W,CV_8UC3, cv::Scalar(0,0,0)) ;",
 "",
 " cv::normalize(hist_blue,hist_blue,0,hist_H, cv::NORM_MINMAX); ",
 "",
 " cv::normalize(hist_green,hist_green,0,hist_H, cv::NORM_MINMAX); ",
 "",
 " cv::normalize(hist_red,hist_red,0,hist_H, cv::NORM_MINMAX); ",
 "",
 " for(int i = 1 ; i < histSize;i++)",
 " {",
 " cv::line(histUni,",
 " cv::Point(i-1,hist_H-(hist_blue.at<float>(i-1))),",
 " cv::Point(i,hist_H-(hist_blue.at<float>(i))),",
 " cv::Scalar(255,0,0),3,8,0); ",
 "",
 " cv::line(histUni,",
 " cv::Point(i-1,hist_H-(hist_green.at<float>(i-1))),",
 " cv::Point(i,hist_H-(hist_green.at<float>(i))),",
 " cv::Scalar(0,255,0),3,8,0);",
 "",
 " cv::line(histUni,",
 " cv::Point(i-1,hist_H-(hist_red.at<float>(i-1))),",
 " cv::Point(i,hist_H-(hist_red.at<float>(i))),",
 " cv::Scalar(0,0,255),3,8,0); ",
 " }",
 "",
 " cv::imshow(\"original\" , img); ",
 " cv::waitKey(0) ;",
 " cv::imshow(\"allinone\" , histUni); ",
 " cv::waitKey(0) ;",
 " ",
 "",
 " return 0; ",
 "}",
 "//EQUALIZED IMAGE ",
 "int main()",
 "{",
 " cv::Mat img = cv::imread(\"/home/kpit/opencv/samples/data/messi5.jpg\", cv::IMREAD_GRAYSCALE); ",
 " cv::imshow(\"normal\", img); ",
 " cv::waitKey(0) ;",
 " cv::Mat res ; ",
 " cv::equalizeHist(img,res); ",
 "",
 " cv::imshow(\"equalized\", res); ",
 " cv::waitKey(0) ;",
 "",
 "}",
 "",
 "",
 ""
 ],
 "description": ""
 },

 "splitmergecrop": {
 "prefix": "ooo****",
 "body": [
 "int main2()",
 "{",
 " //___________________SPLIT_______________________________",
 " std::string path1 = \"/home/kpit/Downloads/akatsuki.jpg\";",
 " std::string path = \"/home/kpit/opencv/samples/data/lena.jpg\";",
 " cv::Mat img = cv::imread(path, cv::IMREAD_UNCHANGED);",
 "",
 " cv::Mat Channels[3];",
 " cv::split(img, Channels);",
 " cv::Mat blue = Channels[0];",
 " cv::Mat green = Channels[1];",
 " cv::Mat red = Channels[2];",
 "",
 " std::cout << (int)red.at<cv::Vec3b>(0, 0)[0] << \"**\\n\";",
 " std::cout << (int)red.at<cv::Vec3b>(0, 0)[1] << \"**\\n\";",
 " std::cout << (int)red.at<cv::Vec3b>(0, 0)[2] << \"**\\n\";",
 "",
 " std::cout << (int)red.at<uchar>(0, 0) << \"\\n\";",
 " std::cout << (int)red.at<uchar>(0, 1) << \"\\n\";",
 " std::cout << (int)red.at<uchar>(0, 2) << \"\\n\";",
 "",
 " std::cout << blue.channels() << \" \" << green.channels() << \" \" << red.channels() << \"\\n\";",
 " // cv::imshow(\"W1\" , img) ;",
 " // cv::waitKey(0) ;",
 " // cv::imshow(\"blue\" , blue) ;",
 " // cv::waitKey(0) ;",
 " // cv::imshow(\"green\" , green) ;",
 " // cv::waitKey(0) ;",
 " // cv::imshow(\"red\" , red) ;",
 " // cv::waitKey(0) ;",
 "",
 " //_________________MERGE______________________",
 "",
 " cv::Mat imageMerged;",
 " // cv::merge(Channels , 3, imageMerged) ;//way1",
 " cv::merge(std::vector<cv::Mat>{red, green, blue}, imageMerged); // way2",
 " // cv::imshow(\"Merge\" ,imageMerged) ;",
 " // cv::waitKey(0) ;",
 "",
 " //________________ CROP______________________",
 " std::cout << img.rows << \" \" << img.cols << \"\\n\";",
 " cv::Rect rectangle(10, 10, 300, 290);",
 " cv::Mat croppedImage = img(rectangle);",
 " cv::imshow(\"croppedImg\", croppedImage);",
 " cv::waitKey(0);",
 "",
 " return 0;",
 "}"
 ],
 "description": ""
 },

 "affine": {
 "prefix": "ooo****",
 "body": [
 "//AFFINE TRANSFORMATION of image {ROTATE AN IMAGE WITH CERTAIN ANGLE}",
 "int main7()",
 "{",
 " std::string path1 = \"./arrow1.png\" ;",
 " cv::Mat img1 = cv::imread(path1) ;",
 "",
 " cv::imshow(\"normal\", img1); ",
 " cv::waitKey(0) ;",
 "",
 " double angle = -45.0 ; ",
 "",
 " //step 1 : calc the ceter of the image ",
 " cv::Point2f center(img1.cols/2.0 , img1.rows/2.0) ;",
 " //step 2 : call function which cals the affine transformation matrix for rotating the object , so it asks [point from where to rotate , angle , direction to rotate ]",
 " cv::Mat rotationMat = cv::getRotationMatrix2D(center , angle, 1.0) ; ",
 " //step 3 : call a func that can apply the affine transformation to the image ",
 " cv::Mat res ; ",
 " cv::warpAffine(img1,res,rotationMat,img1.size()) ;",
 "",
 " cv::imshow(\"rota\", res); ",
 " cv::waitKey(0) ;",
 " return 0 ; ",
 "}",
 "",
 "// AFFINE TRANSFORMATION {cv::getAffineTransform()}",
 "int main8()",
 "{",
 " std::string path = \"./arrow1.png\" ;",
 " cv::Mat img = cv::imread(path) ;",
 "",
 "",
 " cv::imshow(\"noraml\", img); ",
 " cv::waitKey(0) ;",
 "",
 " cv::Point2f ipmat[3] ; // first selece the 3 cordinates ",
 " cv::Point2f opmat[3] ; // give the final cordinates for all ip-cordinates to move ",
 "",
 " ipmat[0] = cv::Point2f(0,0); ",
 " ipmat[1] = cv::Point2f(0,img.cols-1); ",
 " ipmat[2] = cv::Point2f(img.rows-1 , 0); ",
 "",
 " opmat[0] = cv::Point2f(0,100); ",
 " opmat[1] = cv::Point2f(img.rows-1, img.cols-1); ",
 " opmat[2] = cv::Point2f(0,0); ",
 "",
 " cv::Mat M = cv::getAffineTransform(ipmat,opmat) ;",
 "",
 " cv::Mat res ; ",
 " cv::warpAffine(img,res,M,img.size());",
 "",
 " cv::imshow(\"affine\", res); ",
 " cv::waitKey(0) ;",
 "",
 "// ROTATE AS WELL ",
 "",
 " double angle = 45.0 ; ",
 " cv::Point center = cv::Point(img.rows/2 , img.cols/2) ; ",
 " double scale = 1.0 ;",
 "",
 " cv::Mat transAndRot ; ",
 " cv::Mat N = cv::getRotationMatrix2D(center , angle ,scale) ; ",
 " cv::warpAffine(res, transAndRot , N, img.size()); ",
 "",
 " cv::imshow(\"affine n rotate\", transAndRot); ",
 " cv::waitKey(0) ;",
 "",
 "",
 " return 0 ;",
 "}"
 ],
 "description": ""
 },

 "persepective": {
 "prefix": "ooo****",
 "body": [
 "//PERSEPECTIVE TRANSFORM",
 "using namespace cv ; ",
 "int main9()",
 "{",
 " std::string path = \"/home/kpit/opencv/samples/data/lena.jpg\";",
 " // cv::Mat img = cv::imread(path) ;",
 " cv::Mat inputImage = cv::imread(path) ;",
 " cv::imshow(\"noraml\", inputImage); ",
 " cv::waitKey(0) ;",
 "",
 " cv::Point2f srcPoints[4] ;",
 " cv::Point2f dstPoints[4] ;",
 " srcPoints[0] = Point2f(0, 0); // Top-left corner",
 " srcPoints[1] = Point2f(inputImage.cols, 0); // Top-right corner",
 " srcPoints[2] = Point2f(inputImage.cols, inputImage.rows); // Bottom-right corner",
 " srcPoints[3] = Point2f(0, inputImage.rows); // Bottom-left corner",
 " ",
 " dstPoints[0] = Point2f(0, 0); // Top-left corner",
 " dstPoints[1] = Point2f(inputImage.cols, 0); // Top-right corner",
 " dstPoints[2] = Point2f(inputImage.cols * 0.8, inputImage.rows); // Bottom-right corner",
 " dstPoints[3] = Point2f(inputImage.cols * 0.2, inputImage.rows); // Bottom-left corner",
 "",
 " cv::Mat M = cv::getPerspectiveTransform(srcPoints ,dstPoints) ;",
 "",
 " cv::Mat res ; ",
 "",
 " cv::warpPerspective(inputImage,res,M ,inputImage.size()); ",
 " cv::imshow(\"pers\", res); ",
 " cv::waitKey(0) ;",
 " return 0 ;",
 "}",
 ""
 ],
 "description": ""
 },

 "gammaScast": {
 "prefix": "ooo****",
 "body": [
 "//BRIGHTNESS AND SATURATION CONTROL || SATURATE_casT || GAMMA CORRECTION ",
 "int main10()",
 "{",
 "",
 " // std::string path = \"/home/kpit/opencv/samples/data/lena.jpg\";",
 " std::string path = \"./weather.jpg\";",
 " cv::Mat img = cv::imread(path, cv::IMREAD_UNCHANGED);",
 " int R = img.rows ; ",
 " int C = img.cols ; ",
 "",
 " cv::Mat res = cv::Mat::zeros(img.size(), img.type()) ; ",
 " double alpha = 1.3; ",
 " int beta = 40; ",
 " for(int i = 0 ; i < R ; i++)",
 " {",
 " for(int j = 0 ; j < C ;j++)",
 " {",
 " for(int k = 0 ; k < img.channels() ;k++)",
 " {",
 " res.at<cv::Vec3b>(i,j)[k] = cv::saturate_cast<uchar>(alpha * img.at<cv::Vec3b>(i,j)[k] + beta) ; ",
 " }",
 " }",
 " }",
 " cv::imshow(\"normal\" , img); ",
 " cv::waitKey(0); ",
 " cv::imshow(\"c1\" , res);",
 " cv::waitKey(0); ",
 " cv::Mat gres = cv::Mat::zeros(img.size() , img.type()); ",
 " for(int i = 0 ; i < R ; i++)",
 " {",
 " for(int j = 0 ; j < C ;j++)",
 " {",
 " for(int k = 0 ; k < img.channels() ;k++)",
 " {",
 " gres.at<cv::Vec3b>(i,j)[k] = cv::saturate_cast<uchar>(pow(img.at<cv::Vec3b>(i,j)[k] / 255.0, 0.4 ) * 255.0); ",
 " }",
 " }",
 " }",
 " //gc => [ijk = sc<uchar>(pow(ijk / 255.0 , gamma) * 255.0)]",
 " cv::imshow(\"c2\" , gres);",
 " cv::waitKey(0); ",
 " return 0 ; ",
 "}"
 ],
 "description": ""
 },

 "spatial": {
 "prefix": "ooo****",
 "body": [
 "//SPATIAL FILTERING ",
 "int main11()",
 "{",
 " std::string path = \"/home/kpit/opencv/samples/data/lena.jpg\";",
 " cv::Mat img = cv::imread(path) ;",
 " cv::imshow(\"original_image\" , img); ",
 " cv::waitKey(0) ;",
 " ",
 " //**********************************************************",
 " cv::Mat Gres ;",
 " cv::GaussianBlur(img,Gres,cv::Size(11,11),1000,1,cv::BORDER_ISOLATED); ",
 " cv::imshow(\"GAUSSIAN_BLUR\" , Gres); ",
 " cv::waitKey(0) ;",
 " //**********************************************************",
 " cv::Mat Bres ; ",
 " cv::blur(img,Bres,cv::Size(15,15),cv::Point(1,1),cv::BORDER_DEFAULT); ",
 " cv::imshow(\"BLUR\" , Bres); ",
 " cv::waitKey(0) ;",
 " //**********************************************************",
 " cv::Mat Boxres; ",
 " cv::boxFilter(img,Boxres,-1,cv::Size(5,5),cv::Point(-1,-1),false,cv::BORDER_DEFAULT) ; ",
 " cv::imshow(\"BOX_FILTER\" , Boxres); ",
 " cv::waitKey(0) ;",
 " //**********************************************************",
 " cv::Mat Mres ;",
 " cv::medianBlur(img,Mres,15);",
 " cv::imshow(\"MEDIAN_BLUR\" , Mres); ",
 " cv::waitKey(0) ;",
 " //**********************************************************",
 " // cv::Mat TWODres; ",
 " // cv::Mat Kernel = (cv::Mat_<float>(3,3) << )",
 " return 0 ; ",
 "}",
 "//FILTER2D 3 cases ",
 "int main12()",
 "{",
 " std::string path = \"/home/kpit/opencv/samples/data/lena.jpg\";",
 " cv::Mat img = cv::imread(path) ;",
 " cv::imshow(\"original_image\" , img); ",
 " cv::waitKey(0) ; ",
 "//BOX FILTER ",
 " cv::Mat res1 ;",
 " cv::Mat Kernel1 = (cv::Mat_<float>(3,3)<<1,1,1,1,1,1,1,1,1)/9 ;",
 " cv::filter2D(img,res1,-1,Kernel1,cv::Point(-1,-1),0.0,cv::BORDER_DEFAULT) ;",
 " cv::imshow(\"BOX_FILTER\" , res1); ",
 " cv::waitKey(0) ;",
 "",
 " cv::Mat res2 ; ",
 " cv::Mat Kernel2 = (cv::Mat_<float>(3,3) << 0,-1,0,-1,5,-1,0,-1,0); ",
 " cv::filter2D(img,res2,-1,Kernel2); ",
 " cv::imshow(\"SHARPENING\" , res2); ",
 " cv::waitKey(0) ;",
 "",
 " cv::Mat res3 ; ",
 " cv::Mat Kernel3 = (cv::Mat_<float>(3,3)<<-1,0,1,-2,0,-2,-1,0,1); ",
 " cv::filter2D(img,res3,-1,Kernel3) ;",
 " cv::imshow(\"EDGE_DETECTOIN\" , res2); ",
 " cv::waitKey(0) ;",
 " return 0 ; ",
 "}"
 ],
 "description": ""
 },

 "MORPHOLOGICAL": {
 "prefix": "oooo****",
 "body": [
 "int main6(int argc, char const *argv[])",
 "{",
 " Mat img = imread(\"./Girl.jpg\");",
 " std::vector<Mat> channels;",
 " split(img, channels);",
 " imshow(\"main\", img);",
 " waitKey(0);",
 " ",
 " for (int i = 0; i < 3; ++i)",
 " {",
 " channels[i] = 255 - channels[i];",
 " }",
 " ",
 " Mat invertedImg;",
 " merge(channels, invertedImg);",
 " ",
 " imshow(\"inverted\", invertedImg);",
 " waitKey(0);",
 " ",
 " Mat out;",
 " // Mat kernal = getStructuringElement(MORPH_ELLIPSE, Size(3, 3));",
 " std::vector<std::vector<float>> v={{-1,1,8},",
 " {-1,1,-1},{-1,1,-1 },{-1,1,-1}};",
 " Mat kernal = vectorToMat(v);",
 " // kernal = 255 - kernal;",
 " erode(invertedImg, out, kernal, Point(-1, -1), 5);",
 " imshow(\"erode\", out);",
 " waitKey(0);",
 " ",
 " dilate(invertedImg, out, kernal, Point(-1, -1), 5);",
 " imshow(\"dilate\", out);",
 " waitKey(0);",
 " ",
 " cv::morphologyEx(invertedImg, out, cv::MORPH_OPEN, kernal);",
 " cv::imshow(\"Opened Image\", out);",
 " cv::waitKey(0);",
 " ",
 " cv::morphologyEx(img, out, cv::MORPH_CLOSE, kernal);",
 " cv::imshow(\"Closed Image\", out);",
 " cv::waitKey(0);",
 " ",
 " cv::morphologyEx(img, out, cv::MORPH_GRADIENT, kernal);",
 " cv::imshow(\"Morphological Gradient\", out);",
 " cv::waitKey(0);",
 " ",
 " cv::morphologyEx(invertedImg, out, cv::MORPH_TOPHAT, kernal);",
 " cv::imshow(\"Top Hat\", out);",
 " cv::waitKey(0);",
 " ",
 " cv::morphologyEx(img, out, cv::MORPH_BLACKHAT, kernal);",
 " cv::imshow(\"Black Hat\", out);",
 " cv::waitKey(0);",
 " return 0;",
 "}"
 ],
 "description": "MORPHOLOGICAL"
 }, 
 "video": {
 "prefix": "oooo****",
 "body": [
 "",
 "int main() {",
 " // Open the default camera (usually 0)",
 " cv::VideoCapture cap(0);",
 " ",
 " // Check if the camera opened successfully",
 " if (!cap.isOpened()) {",
 " std::cerr << \"Error: Failed to open camera\" << std::endl;",
 " return -1;",
 " }",
 "",
 " // Create a window to display the camera feed",
 " cv::namedWindow(\"Camera Feed\", cv::WINDOW_NORMAL);",
 "",
 " // Flag to indicate if photo capture is requested",
 " bool capture_requested = false;",
 "",
 " while (true) {",
 " // Capture frame-by-frame",
 " cv::Mat frame;",
 " cap >> frame;",
 "",
 " // Check if the frame is empty",
 " if (frame.empty()) {",
 " std::cerr << \"Error: Failed to capture frame\" << std::endl;",
 " break;",
 " }",
 "",
 " // Display the frame",
 " cv::imshow(\"Camera Feed\", frame);",
 "",
 " // Check for key press (30 ms)",
 " char key = cv::waitKey(30);",
 " ",
 " // If 's' is pressed, request photo capture",
 " if (key == 's') {",
 " capture_requested = true;",
 " }",
 " // If 'q' is pressed, quit the program",
 " else if (key == 'q') {",
 " break;",
 " }",
 "",
 " // Check if photo capture is requested",
 " if (capture_requested) {",
 " // Save the photo",
 " std::string filename = \"captured_photo.jpg\";",
 " cv::imwrite(filename, frame);",
 " std::cout << \"Photo saved as \" << filename << std::endl;",
 "",
 " // Reset the flag",
 " capture_requested = false;",
 " }",
 " }",
 "",
 " // Release the camera",
 " cap.release();",
 "",
 " // Close all OpenCV windows",
 " cv::destroyAllWindows();",
 "",
 " return 0;",
 "}",
 ""
 ],
 "description": "video"
 }

